import React, { useEffect, useState, useContext } from 'react';
import { useParams } from 'react-router-dom';
import { EventContext } from '../context/EventContext';
import { QueryContext } from '../context/QueryContext';
import EventChart from '../charts/EventChart';

interface EventContainerProps {
  sizing: string;
  colourGenerator: Function;
}

interface Params {
  service: string;
}

const EventContainer: React.FC<EventContainerProps> = React.memo(props => {
  const { eventData } = useContext(EventContext);
  const { selectedMetrics } = useContext(QueryContext);
  const { service } = useParams<keyof Params>() as Params;
  // eventChartsArr contains all charts of all metrics
  const [eventChartsArr, setEventChartsArr] = useState<JSX.Element[]>([]);

  /*
  Chronos11 -- Unfortunately, eventData is not in a good place for UI/UX purposes. These charts are being rendered 1:1 with the list of metrics (over 500).
  These metrics are scraped and generated by Prometheus, and should be sent to a Grafana instance
  to be displayed with a Grafana dashboard, but we didn't realize this was happening until we were too close to launch to fix it.
  It would be wonderful if a future iteration could manipulate the prometheus configuration in the kubernetes example to send its data
  to an instance of Grafana, and integrate Grafana's dashboard into Chronos to visualize the data.
  */

  const filterSelectedEventMetricsandData = eventDataObj => {
    const filteredEventData = {};
    // there's only one element in the selected metrics array for now...
    // selectedMetrics is... [{Event: ['metric', 'names', 'as', 'strings']}]
    // use this array of selected metrics to filter the eventData down to only the metrics we want to see
    const selectedArr = selectedMetrics[0].Event;
    // only one service... 'Event'
    for (const service in eventDataObj) {
      filteredEventData[service] = {};
      // define the object of all the metrics
      const serviceMetricsObject = eventDataObj[service];
      // iterate through all the metrics
      for (const metricName in serviceMetricsObject) {
        // if the metric name matches a string in the selectedArr, we add it to our filtered object
        if (selectedArr.includes(metricName)) {
          filteredEventData[service][metricName] = serviceMetricsObject[metricName];
        }
      }
    }
    return filteredEventData;
  };

  // iterate over the filtered event data to build an array of charts, then set the event charts array state
  const generateEventCharts = filteredEventDataObj => {
    const chartsArray: JSX.Element[] = [];
    const keymaker = () => {
      return Math.floor(Math.random() * 1000);
    };
    for (const service in filteredEventDataObj) {
      const metricObject = filteredEventDataObj[service];
      for (const metricName in metricObject) {
        const chartData = metricObject[metricName];
        chartsArray.push(
          <EventChart
            key={'E' + keymaker()}
            metricName={metricName}
            chartData={chartData}
          />
        );
      }
    }
    setEventChartsArr(chartsArray);
  };
  // invoke the filter and generate functions to render charts
  useEffect(() => {
    const filteredEventData = filterSelectedEventMetricsandData(eventData);
    generateEventCharts(filteredEventData);
  }, [eventData, service]);

  return (
    <div>
      {service.includes('kafkametrics') || service.includes('kubernetesmetrics')
        ? eventChartsArr
        : []}
    </div>
  );
});

export default EventContainer;
