import React, { useEffect, useState, useContext } from 'react';
import { useParams } from 'react-router-dom';
import { EventContext } from '../context/EventContext';
import { QueryContext } from '../context/QueryContext';
import EventChart from '../charts/EventChart';
import { Button } from '@material-ui/core';
import GrafanaEventChart from '../charts/GrafanaEventChart';
import { get } from 'http';
import axios from 'axios';

interface EventContainerProps {
  sizing: string;
  colourGenerator: Function;
}

interface Params {
  service: string;
}
interface MetricObject {
  [key: string]: {
    value: string[],
    time: string[]
  }
}

interface EventDataObject {
  [key: string]: MetricObject
}

const EventContainer: React.FC<EventContainerProps> = React.memo(props => {
  const { eventData } = useContext(EventContext);
  const { selectedMetrics } = useContext(QueryContext);
  const { service } = useParams<keyof Params>() as Params;
  const { sizing, colourGenerator } = props;
  // eventChartsArr contains all charts of all metrics
  const [eventChartsArr, setEventChartsArr] = useState<JSX.Element[]>([]);
  const [currIndex, setCurrIndex] = useState(0);
  const [currChunk, setCurrChunk] = useState<JSX.Element[]>([]);
  const chunkSize = 7;

  // nextChunk and prevChunk handle button clicks to show a limited number of graphs per page to prevent crashing
  function nextChunk() {
    const nextChunk = eventChartsArr.slice(currIndex, currIndex + chunkSize);
    setCurrChunk(nextChunk);
    setCurrIndex(currIndex + chunkSize);
  }
  function prevChunk() {
    const prevChunk = eventChartsArr.slice(currIndex - 2 * chunkSize, currIndex - chunkSize);
    setCurrChunk(prevChunk);
    setCurrIndex(currIndex - chunkSize);
  }

  /*
  Chronos11 -- Unfortunately, eventData is not in a good place for UI/UX purposes. These charts are being rendered 1:1 with the list of metrics (over 500).
  These metrics are scraped and generated by Prometheus, and should be sent to a Grafana instance to be displayed with
  a Grafana dashboard, but we didn't realize this was happening until we were too close to launch to fix it.
  It would be wonderful if a future iteration could manipulate the prometheus configuration in the kubernetes example to send its data
  to an instance of Grafana, and integrate Grafana's dashboard into Chronos to visualize the data.
  */

  const filterSelectedEventMetricsandData = (eventDataObj: EventDataObject): EventDataObject => {
    const filteredEventData = {};
    // there's only one element in the selected metrics array for now...
    // selectedMetrics is... [{Event: ['metric', 'names', 'as', 'strings']}]
    // use this array of selected metrics to filter the eventData down to only the metrics we want to see
    const selectedArr = selectedMetrics[0].Event;
    console.log('selectedArr IS: ', selectedArr)
    // only one service... 'Event'
    for (const service in eventDataObj) {
      filteredEventData[service] = {};
      // define the object of all the metrics
      const serviceMetricsObject = eventDataObj[service];
      console.log('serviceMetricsObject IS: ', serviceMetricsObject)
      // iterate through all the metrics
      for (const metricName in serviceMetricsObject) {
        // if the metric name matches a string in the selectedArr, we add it to our filtered object
        if (selectedArr.includes(metricName)) {
          filteredEventData[service][metricName] = serviceMetricsObject[metricName];
        }
      };
    };
    console.log('filteredEventData IS: ', filteredEventData)
    return filteredEventData;
  };

  // helper function for geting only the names of the metrics
  const getIndex = (str: string, substr: string, ind: number): number => {
    let Len = str.length,
      i = -1;
    while (ind-- && i++ < Len) {
      i = str.indexOf(substr, i);
      if (i < 0) break;
    }
    return i;
  }

  // iterate over the filtered event data to build an array of charts, then set the event charts array state
  const generateEventCharts = (filteredEventDataObj: EventDataObject): void => {
    const chartsArray: JSX.Element[] = [];
    const grafanaChartsArray: JSX.Element[] = [];
    let parsedName: string = '';
    const keymaker = () => {
      return Math.floor(Math.random() * 1000);
    };
    for (const service in filteredEventDataObj) {
      const metricObject = filteredEventDataObj[service];
      for (const metricName in metricObject) {
        console.log('metricName IS: ', metricName)
        //parsedName = metricName.replace(/.*\/.*\//g, '')
        const chartData = metricObject[metricName];
        console.log('chartData IS: ', chartData)
        // plotting using plotly
        // chartsArray.push(
        //   <EventChart
        //     key={'E' + keymaker()}
        //     metricName={metricName}
        //     chartData={chartData}
        //     sizing={sizing}
        //     colourGenerator={colourGenerator}
        //   />
        // );
        // plotting using grafana
        console.log("I'm here")
        grafanaChartsArray.push(
          <GrafanaEventChart metricName={metricName} />);
      }
    }
    console.log(grafanaChartsArray)
    setEventChartsArr(grafanaChartsArray);
    setCurrChunk(grafanaChartsArray.slice(currIndex, currIndex + chunkSize));
    setCurrIndex(currIndex + chunkSize);
  };

  // function createGrafanaPanelObject(
  //   metric,
  //   datasource
  // ) {
  //   // Create a panel object to be used within dashboards.
  //   const panel = {
  //     "datasource": datasource,
  //     "fieldConfig": {
  //       "defaults": {
  //         "color": {
  //           "mode": "palette-classic"
  //         },
  //         "custom": {
  //           "axisCenteredZero": false,
  //           "axisColorMode": "text",
  //           "axisLabel": "",
  //           "axisPlacement": "auto",
  //           "barAlignment": 0,
  //           "drawStyle": "line",
  //           "fillOpacity": 0,
  //           "gradientMode": "none",
  //           "hideFrom": {
  //             "legend": false,
  //             "tooltip": false,
  //             "viz": false
  //           },
  //           "lineInterpolation": "linear",
  //           "lineWidth": 1,
  //           "pointSize": 5,
  //           "scaleDistribution": {
  //             "type": "linear"
  //           },
  //           "showPoints": "auto",
  //           "spanNulls": false,
  //           "stacking": {
  //             "group": "A",
  //             "mode": "none"
  //           },
  //           "thresholdsStyle": {
  //             "mode": "off"
  //           }
  //         },
  //         "mappings": [],
  //         "thresholds": {
  //           "mode": "absolute",
  //           "steps": [
  //             {
  //               "color": "green",
  //               "value": null
  //             },
  //             {
  //               "color": "red",
  //               "value": 80
  //             }
  //           ]
  //         },
  //         "min": 0
  //       },
  //       "overrides": []
  //     },
  //     "gridPos": {
  //       "h": 8,
  //       "w": 12,
  //       "x": 0,
  //       "y": 0
  //     },
  //     "options": {
  //       "legend": {
  //         "calcs": [],
  //         "displayMode": "list",
  //         "placement": "bottom",
  //         "showLegend": true
  //       },
  //       "tooltip": {
  //         "mode": "single",
  //         "sort": "none"
  //       }
  //     },
  //     "id": 1,
  //     "targets": [{
  //       "datasource": datasource,
  //       "editorMode": "builder",
  //       "expr": metric,
  //       "instant": false,
  //       "range": true,
  //       "refId": "A"
  //     }],
  //     "title": metric,
  //     "type": "timeseries",
  //     "interval": "2s"
  //   }
  //   return panel;
  // }

  // const createGrafanaDashboard = async (
  //   metric,
  //   datasource,
  // ) => {
  //   // create dashboard object boilerplate
  //   const dashboard = {
  //     "dashboard": {
  //       "id": null,
  //       "uid": metric,
  //       "title": metric,
  //       "tags": ["templated"],
  //       "timezone": "browser",
  //       "schemaVersion": 16,
  //       "version": 0,
  //       "refresh": "10s",
  //       panels: [{
  //         "datasource": datasource,
  //         "fieldConfig": {
  //           "defaults": {
  //             "color": {
  //               "mode": "palette-classic"
  //             },
  //             "custom": {
  //               "axisCenteredZero": false,
  //               "axisColorMode": "text",
  //               "axisLabel": "",
  //               "axisPlacement": "auto",
  //               "barAlignment": 0,
  //               "drawStyle": "line",
  //               "fillOpacity": 0,
  //               "gradientMode": "none",
  //               "hideFrom": {
  //                 "legend": false,
  //                 "tooltip": false,
  //                 "viz": false
  //               },
  //               "lineInterpolation": "linear",
  //               "lineWidth": 1,
  //               "pointSize": 5,
  //               "scaleDistribution": {
  //                 "type": "linear"
  //               },
  //               "showPoints": "auto",
  //               "spanNulls": false,
  //               "stacking": {
  //                 "group": "A",
  //                 "mode": "none"
  //               },
  //               "thresholdsStyle": {
  //                 "mode": "off"
  //               }
  //             },
  //             "mappings": [],
  //             "thresholds": {
  //               "mode": "absolute",
  //               "steps": [
  //                 {
  //                   "color": "green",
  //                   "value": null
  //                 },
  //                 {
  //                   "color": "red",
  //                   "value": 80
  //                 }
  //               ]
  //             },
  //             "min": 0
  //           },
  //           "overrides": []
  //         },
  //         "gridPos": {
  //           "h": 8,
  //           "w": 12,
  //           "x": 0,
  //           "y": 0
  //         },
  //         "options": {
  //           "legend": {
  //             "calcs": [],
  //             "displayMode": "list",
  //             "placement": "bottom",
  //             "showLegend": true
  //           },
  //           "tooltip": {
  //             "mode": "single",
  //             "sort": "none"
  //           }
  //         },
  //         "id": 1,
  //         "targets": [{
  //           "datasource": datasource,
  //           "editorMode": "builder",
  //           "expr": metric,
  //           "instant": false,
  //           "range": true,
  //           "refId": "A"
  //         }],
  //         "title": metric,
  //         "type": "timeseries",
  //         "interval": "2s"
  //       }],
  //     },
  //     folderId: 0,
  //     overwrite: true,
  //   };


  //   // push panel into dashboard object with a line for each metric in promQLQueries object
  //   //dashboard.dashboard.panels.push(createGrafanaPanelObject(metric, datasource));

  //   try {
  //     // POST request to Grafana Dashboard API to create a dashboard
  //     const dashboardResponse = await axios.post(
  //       'http://localhost:32000/api/dashboards/db',
  //       JSON.stringify(dashboard),
  //       {
  //         headers: {
  //           'Content-Type': 'application/json',
  //           'Authorization': 'Bearer glsa_k6xRnpAs8yiOJBI1eQTqyuRbRhI4lHAi_16c38fd4'
  //         },
  //       }
  //     );

  //     // Descriptive error log for developers
  //     if (dashboardResponse.status >= 400) {
  //       console.log(
  //         'Error with POST request to Grafana Dashboards API. In createGrafanaDashboardObject.'
  //       );
  //     } else {
  //       // A simple console log to show when graphs are done being posted to Grafana.
  //       console.log(`📊 Grafana graphs 📊 for the ${metric} container are ready!!`);
  //     }
  //   } catch (err) {
  //     console.log(err);
  //   }
  // }

  // const getGrafanaDatasource = async () => {
  //   // Fetch datasource information from grafana API.
  //   // This datasource is PRECONFIGURED on launch using grafana config.
  //   const datasourceResponse = await axios.get('http://localhost:32000/api/datasources', {
  //     //mode: 'no-cors',
  //     headers: {
  //       "Access-Control-Allow-Origin": "*",
  //       'Content-Type': 'application/json',
  //       'Authorization': 'Bearer glsa_k6xRnpAs8yiOJBI1eQTqyuRbRhI4lHAi_16c38fd4'
  //     },
  //   });

  //   // Create a datasource object to be used within panels.
  //   const datasource = {
  //     type: datasourceResponse[0].type,
  //     uid: datasourceResponse[0].uid,
  //   };

  //   return datasource;
  // }

  // // const createDashboards = async (filteredEventData) => {
  // //   for (let key in filteredEventData.Event) {
  // //     try {
  // //       let datasource = await getGrafanaDatasource();
  // //       await createGrafanaDashboard(key.replace(/.*\/.*\//g, ''), datasource);
  // //     } catch (err) {
  // //       console.error(err);
  // //     }
  // //   }
  // // }

  // invoke the filter and generate functions to render charts
  useEffect(() => {
    const filteredEventData = filterSelectedEventMetricsandData(eventData);
    // const createDashboards = async (filteredEventData) => {
    //   for (let key in filteredEventData.Event) {
    //     try {
    //       let datasource = await getGrafanaDatasource();
    //       console.log("dssd")
    //       await createGrafanaDashboard(key.replace(/.*\/.*\//g, ''), datasource);
    //     } catch (err) {
    //       console.error(err);
    //     }
    //   }
    // }
    // createDashboards(filteredEventData)
    generateEventCharts(filteredEventData);

  }, [eventData, service]);

  return (
    <div>
      {service.includes('kafkametrics') || service.includes('kubernetesmetrics') ? currChunk : []}
      {eventChartsArr.length > chunkSize && (
        <>
          <Button id="prevCharts" onClick={prevChunk} variant="contained" color="primary" disabled={currIndex <= chunkSize}>
            Prev
          </Button>
          <Button id="nextCharts" onClick={nextChunk} variant="contained" color="primary" disabled={currIndex >= eventChartsArr.length}>
            Next
          </Button>
        </>
      )}
    </div>
  );
});

export default EventContainer;

